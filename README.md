## Dating Application

### Требования для запуска
Перед запуском приложения убедитесь, что у вас на компьютере установлен `docker` и `git` 

### Запуск впервые
Для клонирования репозитория выполните команду:
```
git clone https://github.com/mariiemik/DatingApplication.git
```
В результате у вас на компьютере появится директория `DatingApplication` с исходным кодом приложения

### Запуск приложения
Для запуска войдите в появившуюся директорию `DatingApplication` и выполните команду:
```
docker compose up --build
```
В результате, API бекенда станет доступно по адресу:
```
http://localhost:7000
```
Интерфейс станет доступен по адресу:
```
http://localhost:9000
```
База данных станет доступна на:
```
localhost:5432
```

### Выключение приложения
Для завершения работы приложения выполните команду:
```
docker compose down
```
---

# DatingAPP

## Описание проекта

**DatingAPP** — это приложение для знакомств, которое предоставляет удобный способ поиска интересных людей для общения или романтических отношений. Пользователи создают персонализированные профили с описанием и фотографиями, указывают информацию о себе, а также могут оценивать профили других участников.

Основной акцент делается на взаимное согласие: контактная информация становится доступной только после того, как обе стороны выразили симпатию, что делает будущее общение комфортным и взаимно желанным.

## Предметная область

- Онлайн-знакомства.
- Социальные взаимодействия и коммуникация.


## Данные в проекте DatingAPP
![image](https://github.com/user-attachments/assets/4492bcfa-c484-4547-843f-3926b1999603)


### Таблицы и их ограничения

#### Таблица `tokens`
- **Id**: первичный ключ, уникальное значение, автоинкремент.
- **Token**: строка фиксированной длины (36 символов), не может быть `NULL`.
- **user_id**: внешний ключ, ссылается на `users.id`, не может быть `NULL`.
- **update_at**: не может быть `NULL`, хранит временную метку.

#### Таблица `users`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **email**: строка длиной до 50 символов, уникальное значение, не может быть `NULL`.
- **password_hash**: строка длиной до 256 символов, не может быть `NULL`.
- **role**: строка длиной до 10 символов, значение по умолчанию — `user`.
- **moderated**: логический тип, значение по умолчанию — `False`.
- **active**: логический тип, значение по умолчанию — `True`.

#### Таблица `profiles`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **user_id**: внешний ключ, ссылается на `users.id`, не может быть `NULL`.
- **name**: строка длиной до 50 символов, может быть `NULL`.
- **surname**: строка длиной до 50 символов, может быть `NULL`.
- **country_id**: внешний ключ, ссылается на `countries.id`, может быть `NULL`.
- **city_id**: внешний ключ, ссылается на `cities.id`, может быть `NULL`.
- **gender**: логический тип, может быть `NULL` (True- женщина, False- мужчина).
- **age**: целое число, может быть `NULL`.
- **nickname_tg**: строка длиной до 64 символов, может быть `NULL`.
- **about_me**: строка длиной до 300 символов, может быть `NULL`.

#### Таблица `cities`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **city_name**: строка длиной до 50 символов, уникальное значение, не может быть `NULL`.

#### Таблица `countries`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **country_name**: строка длиной до 50 символов, уникальное значение, не может быть `NULL`.

#### Таблица `likes`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **user_id_from**: внешний ключ, ссылается на `users.id`, не может быть `NULL`.
- **user_id_to**: внешний ключ, ссылается на `users.id`, не может быть `NULL`.
- **Дополнительное ограничение**: значения `user_id_from` и `user_id_to` не могут совпадать.

#### Таблица `photos`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **profile_id**: внешний ключ, ссылается на `profiles.id`, не может быть `NULL`.
- **photo_url**: строка длиной до 150 символов, может быть `NULL`.

#### Таблица `complaints`
- **id**: первичный ключ, уникальное значение, автоинкремент.
- **profile_id_to**: внешний ключ, ссылается на `profiles.id`, не может быть `NULL`.
- **letter**: строка длиной до 300 символов, не может быть `NULL`.
- **added_at**: не может быть `NULL`, хранит временную метку.


### Общие ограничения целостности

#### Ссылочная целостность
- Все внешние ключи должны ссылаться на существующие записи.
- Удаление записей, на которые ссылаются другие таблицы, запрещено (удаление зависимых данных выполняется вручную).

#### Уникальность
- Поле `email`должно быть уникальными.

#### Логические ограничения
- Пользователь не может лайкнуть сам себя (`user_id_from != user_id_to` в таблице `likes`).
- У пользователя может быть только один профиль.

#### Проверка формата данных
- Пользователь может загрузить только фотографии формата PNG или JPEG.

#### Автозаполнение
- Поле `added_at` в таблице `complaints` автоматически заполняется текущей датой и временем.


## Пользовательские роли

### Роль: Moderator
- **Ответственность**: Просмотр жалоб от пользоватеелй, профилей, внесение изменений в профиль при нарушениях или деактивация пользователя при грубом нарушении.
- **Количество пользователей в роли**: зависит от потребностей проекта.

### Роль: User
- **Ответственность**: Размещение контента, просмотр профилей других пользователей, сообщение о размещении неподобающего контента у других пользователей.
- **Количество пользователей в роли**: зависит от масштаба платформы.


## Технологии разработки

- **Backend**: Python
- **Frontend**: HTML, CSS, JavaScript
- **Фреймворк**: Vue.js
- **Инструменты разработки**: Git, Docker, Nginx
- **API**: RESTful API
- **СУБД**: PostgreSQL
- **ОРМ**: SQLAlchemy


## Описание транзакций

### 1. Функция `delete_user_fully`

Функция `delete_user_fully` выполняет полное удаление пользователя из базы данных, включая все связанные с ним данные, в рамках одной транзакции. В случае возникновения ошибки на любом этапе выполнения транзакции происходит откат изменений, что предотвращает неконсистентность данных.

#### Алгоритм работы:
1. **Поиск пользователя**: Функция выполняет запрос в таблицу `User` с целью нахождения пользователя по его уникальному идентификатору (`user_id`). Если пользователь не найден, функция возвращает `False` и завершает выполнение.
2. **Удаление связанных данных**:
   - Если пользователь найден, выполняется удаление его токенf с помощью функции `delete_user_token`.
   - Удаляются все лайки пользователя с помощью функции `delete_user_likes`.
3. **Удаление данных профиля**:
   - Функция ищет профиль пользователя в таблице `Profile` по его `user_id`. Если профиль существует, выполняются следующие операции:
     - Удаляются все фотографии профиля с помощью функции `delete_user_photos`.
     - Удаляются все жалобы, связанные с профилем, через функцию `delete_complaints_for_profile`.
     - Профиль пользователя удаляется с помощью функции `delete_user_profile`.
4. **Удаление пользователя**: После удаления всех связанных данных, сам пользователь удаляется из базы данных с помощью функции `delete_user`.
5. **Обработка ошибок**: Если в процессе выполнения операции возникает ошибка (исключение `SQLAlchemyError`), транзакция откатывается с помощью `db.rollback()`, и функция возвращает `False`. В случае успешного завершения операции возвращается `True`.

### 2. Функция `delete_complaints_for_profile`

Функция `delete_complaints_for_profile` удаляет все жалобы, связанные с определённым профилем, из базы данных.

#### Алгоритм работы:
1. **Удаление жалоб**: Функция выполняет запрос к таблице `Complaint` с фильтрацией по полю `profile_id_to`, которое должно совпадать с переданным параметром `profile_id`. Все записи, соответствующие этому фильтру, удаляются методом `.delete()`.
2. **Коммит транзакции**: После выполнения удаления всех жалоб изменения фиксируются в базе данных с помощью вызова `db.commit()`. Если операция прошла успешно, функция возвращает `True`.
3. **Обработка ошибок**: В случае возникновения ошибки (исключение `SQLAlchemyError`) транзакция откатывается через `db.rollback()`, и функция возвращает `False`.

